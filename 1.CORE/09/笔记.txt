
1.	创建日期对象第四种：复制日期对象
	var date1=new Date();
	var date2=new Date(date1.getTime());
	date2.set(date2.get()+计算);

2.错误/异常处理：
	错误：导致程序无法继续执行的异常状态；
	js中一旦发生错误，就会创建一个Error类型对象；

	js中有6种错误：
		SyntaxError:语法错误；
		ReferenceError:引用错误，找不到变量或对象；
		TypeError:类型错误，错误的使用了对象中的方法；
		RangeError:范围错误；参数范围，tofixed();超0-20；
		EvalError:调用Eval函数出错；
		URLError:URL出错；

	错误处理：程序发生错误时，保证程序不退出或正常退出；
	怎样处理：
	语法：tryCatch块：3部分；
		try{
		可能出错的代码段；
		}catch(err){		//仅在发生错误是才执行，一旦发生错误，变量err中就会自动存入Error对象；
		1.记录/显示错误的信息；
		2.继续向调用者抛出异常；
		}[finally{		//无论对错，一定都会执行的代码段；
		释放资源；
		}]
	何时需要定义错误处理：
		某段只要"有可能"出错；就要放在tryCatch里；
		未知错误采用tryCatch；
		已经预知的错误，用if else；

	tryCatch 解决浏览器兼容问题：

	抛出自定义异常：throw new Error("自定义错误消息");
	      比如：如果程序员甲定义了一个方法，被程序员乙调用
		     如果程序员乙错误的使用甲的方法，
		     甲的方法中就要抛出自定义错误消息
		     乙在调用时，就要将甲的方法包在try块中

3.function
	- js中一切都是对象，函数名是引用函数定义对象的变量；
	
	1.arguments对象：
	重载：程序中可定义多个相同函数名，不同参数列表的函数；
		调用者不必区分每个函数的参数，
		执行时，程序根据传入的参数个数，自动判断选择哪个函数执行；

tmooc/java/java面向对象/类中的方法；

	虽然js语法不支持重载，但可以用arguments对象模拟重载效果；************
	arguments对象：函数对象内，自动创建的专门接受所有参数值的类数组对象；
	arguments[i]		获得传入的下标为i的参数；
	arguments.length	获得传入的参数的个数；

	即时定义了参数变量，arguments对象同样会收到所有参数值；


	2.函数对象本质：
		1.创建函数对象：3种；
			1.声明方式：function 函数名（）{}；	函数名变量提前，函数定义也提前；   定义在调用前后都行；
			2.函数直接量 var 函数名=function(){};	函数名变量提前，函数定义留在原地； 必须定义在调用前；
			3.使用new创建函数类型对象；
				var 函数名=new Function("a","b"...,"函数体");

		2.内存中的函数对象：
			在创建函数对象时:会同时创建2个对象：
				函数对象：函数的定义；
				作用域链对象：保存了函数对象可用变量位置的对象（栈）；********
					      默认第一项指向window;
			调用函数时，又会创建一个对象：
				活动对象：专门保存局部变量的对象；
					  在作用域链对象追加指向活动对象的引用；
			调用后：作用域链中的活动对象的引用出栈；
				活动对象因无人引用而释放；

		3.匿名函数：**********
			定义时，不指定函数名；节省内存；
			匿名函数2大用：
			1.匿名函数自调： 
				定义完，立刻执行，执行完立刻释放；
			  使用：
				只有确定函数"只执行一次"时采用；
			  如何自调：(function(参数){
					函数体 ;
				    })(参数值);
			  匿名函数自调定义在哪就在哪执行，不提前**********

			2.匿名函数回调：
				先将函数作为对象传递给另一个函数，
				由另一个函数自主决定在需要时调用；
				（一个函数需要另一个函数作参数）
			  使用：
				只要将函数作对象传递给另一其他方法调用时；比较器；

		4.闭包***
			问题：局部变量和全局变量的缺陷：
			全局变量：容易全局污染；
			局部变量：无法共享，不能长久保存；

			即 可以共享，长久保存 又 不会全局污染;---->闭包
			解决：3步，闭包三特点：
			1.定义外层函数；封装被保存的局部变量； outer()  var n;
			2.定义内存函数，执行对外层函数局部变量的操作； inner()
			3.外层函数返回 内存函数的对象 ;return inner；
			  并且外层函数被调用，结果被保存在全局变量中，这个全局变量是内存函数；

			何时使用：反复使用局部变量，又避免全局污染，
			缺点：占内存；
